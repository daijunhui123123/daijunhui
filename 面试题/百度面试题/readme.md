## 自我介绍

姓名 + 学校  + 做过什么成绩 +为什么胜任

# 1. 数值的方法 ,意义是什么   
var a=[]
var b=new Array()

a.push()
b.pop()
 1. 创建对象字面量在v8的执行过程相当new了 一个构造函数，通常我们不去new构造函数因为够简洁直观
 2. 因为a

 # 2. promise 有几种状态  可以重复改变
 1. 3种状态 pending  fulfilled rejected
 2. 2种改变状态的方法 resolve reject
 3. 改变状态后 状态不可逆
 4. 改变状态后 执行then方法

 - 红绿灯算法 

 # 3. 输出结果  
const obj1 = { a: 1 }

const obj2 = { b: 2 }

console.log(obj1 === obj2)

console.log(obj1 === obj2)

# 4.聊聊你对语义化的理解   
  - 有哪些东西  header  nav  aside  article  section  footer  
  - 优点：
     1. 可读性好 搜索引擎优化SEO  支持各个终端
# 5. 斐波那契
    递归   和  动态规划  

# 用过什么AI工具   
  1.  chatGPT   （刻意练习prompt技巧，生成一下简单的前端网页，学习）
  2.  Copilot   提升开发效率   
  3. 最近在学习 transformer   opanai  技能，对大模型在学习LangChain ，LLM   
  4. 自己准备一个大模型  ，介绍你给他听


#  讲一讲HTTP请求的三次握手  
   -  三次握手是ticp协议建立连接产生的
    1. 客户端发送连接请求到服务端，客户端状态进入 SYN-SENT状态
    2. 服务端接收到请求连接报文后，返回一个应答（包含ACK序号），服务端进入 SYN-RECEIED状态  
    3. 客户端接收到了同意连接的应答后，还要向服务端发送一个确认收到的报文，客户端进入 ESTABLISHED状态
 
 - 为什么一定要三次握手，俩次不行吗

  不行  假设客户端给服务发送一个建立请求A，但是因为网络问题差，这个请求A超时了，那么tcp会启动超时重传机制，再发送一个新的建立请b，服务端接受到B请求后答应，如果此时就完成建立连接，当客户端和服务端通信完成后，释放了连接，双方都进入Closed状态，但是服务端此时并没有收到客户端的确认，服务端会一直等待客户端的确认，但是客户端已经释放了连接，所以服务端会一直等待客户端的确认，导致服务端一直处于SYN-RECEIVED状态，而客户端一直处于ESTABLISHED状态，所以造成了死锁                                        

- 四次挥手
  1. 客户端A认为



  # 说一说跨越问题   
   

   https：//192.168.31.45:8080/user
   协议号： 域名  ： 端口号/路径 

   - 同源策略  ： 协议号和域名  端口号都相同的地址，浏览器才认为是同源
   - 跨域： 后端返回给浏览器的数据会被浏览器的同源策略给拦截下来

   - 同源策略的目的是数据安全
   ## 解决跨域   （开发阶段好调试） 

      http：//192.168.31.1：8080 （前端）
     
      http：//192.168.31.2：8080 （后端go）

    -  1. JSONP  
    1. ajax请求受同源策略的影响，但是 <script>上的src属性不受同源策略的影响，且该属性也会自动发起请求



